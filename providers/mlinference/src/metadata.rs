use serde::{Deserialize, Serialize};
use thiserror::Error as ThisError;

// #[derive(Serialize, Deserialize)]
// pub struct ModelMetadata {
//     pub model_name: Option<String>,
//     pub graph_encoding: String,
//     pub execution_target: String,
//     pub tensor_type: String,
//     pub tensor_dimensions_in: Option<Vec<u32>>,
//     pub tensor_dimensions_out: Option<Vec<u32>>
// }

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ModelMetadata {
    /// Model name (optional)
    #[serde(default)]
    pub model_name: Option<String>,
    
    /// graph encoding
    #[serde(default)]
    pub graph_encoding: String,
    
    /// execution target
    #[serde(default)]
    pub execution_target: String,
    
    /// tensor type
    #[serde(default)]
    pub tensor_type: String,
    
    /// tensor dimensions in (optional)
    #[serde(default)]
    pub tensor_dimensions_in: Option<Vec<u32>>,
    
    /// tensor dimensions out (optional)
    #[serde(default)]
    pub tensor_dimensions_out: Option<Vec<u32>>
}

impl ModelMetadata {
    /// load metadata from json
    pub fn from_json(data: &[u8]) -> Result<Self, Error> {
        serde_json::from_slice(data).map_err(|e| Error::InvalidParameter(format!("invalid json: {}", e)))
    }
}

/// get first member of
pub fn get_first_member_of(parcels: &Vec<bindle::Parcel>, group: &str) -> Result<bindle::Parcel,()> {
    let members = parcels
    .into_iter()            
    .filter(|parcel| 
        parcel.conditions.is_some() && 
        parcel.conditions.as_ref().unwrap().member_of.is_some()
    )
    .filter(|parcel| parcel.conditions.clone().unwrap().member_of.unwrap().iter().any(|mbs| *mbs == group) )
    .collect::<Vec<&bindle::Parcel>>();

    return match members.len() {
        0 => Err(()),
        _ => Ok(members.first().unwrap().clone().clone())
    };
}

/// errors generated by this crate
#[derive(ThisError, Debug)]
pub enum Error {
    #[error("invalid parameter: {0}")]
    InvalidParameter(String),
}